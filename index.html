<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Matrix Secret - CRT Decryptor</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Mono:wght@700&family=Noto+Sans+TC:wght@900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; font-family: 'Noto Sans Mono', monospace; height: 100vh; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        
        /* CRT æ”¶é›†å€æ¨£å¼ */
        #crt-console {
            position: fixed; bottom: calc(20px + env(safe-area-inset-bottom)); left: 50%;
            transform: translateX(-50%); width: 90%; max-width: 500px;
            background: #020; border: 2px solid #0f4; border-radius: 4px;
            padding: 10px; z-index: 60; pointer-events: none;
            box-shadow: 0 0 15px rgba(0, 255, 68, 0.3);
            display: none; /* åˆå§‹éš±è—ï¼Œç ´è§£æ™‚é–‹å•Ÿ */
        }
        #crt-console.active { display: block; }
        #crt-text {
            color: #0f4; font-size: 18px; line-height: 1.4; min-height: 1.4em;
            text-shadow: 0 0 5px #0f4; letter-spacing: 2px; word-break: break-all;
        }
        /* CRT æƒæç·šæ•ˆæœ */
        #crt-console::before {
            content: " "; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 3px, 3px 100%; pointer-events: none;
        }

        #touch-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; }
        #app-ui { 
            position: absolute; bottom: 0; left: 0; width: 100%; z-index: 100; 
            background: rgba(0,0,0,0.85); backdrop-filter: blur(15px); 
            border-top: 1px solid #0f4; padding-bottom: calc(10px + env(safe-area-inset-bottom));
            transition: transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
            transform: translateY(110%);
        }
        #app-ui.show { transform: translateY(0); }
        #app-ui.viewer-mode { background: transparent; border: none; transform: translateY(0); bottom: 15%; }
        
        .ui-content { padding: 8px 0; display: flex; flex-direction: column; align-items: center; gap: 6px; }
        .ui-row { width: 92%; display: flex; justify-content: space-between; align-items: center; gap: 8px; }
        .btn { flex: 1; height: 46px; background: #111; border: 1px solid #0f4; border-radius: 8px; color: #0f4; font-weight: bold; cursor: pointer; }
        .btn.active { background: #f44; color: #fff; border-color: #fff; box-shadow: 0 0 20px #f44; }
        input[type="text"] { background: #000; border: 1px solid #f44; color: #fff; padding: 10px; border-radius: 6px; flex: 1; outline: none; }
        .control-group { flex: 1; display: flex; flex-direction: column; color: #0f4; font-size: 9px; }
        input[type="range"] { width: 100%; accent-color: #0f4; }
        .creator-only { display: flex; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="canvas-container"></div>
<div id="touch-overlay"></div>

<div id="crt-console">
    <div id="crt-text">_</div>
</div>

<div id="app-ui">
    <div class="ui-content">
        <div class="ui-row creator-only">
            <input type="text" id="decodeInput" placeholder="è¼¸å…¥è¦åŠ å¯†çš„è¨Šæ¯...">
        </div>
        <div class="ui-row creator-only">
            <div class="control-group">
                <label>è¡Œæ•¸: <span id="rowVal">12</span></label>
                <input type="range" id="rowSlider" min="4" max="60" step="2" value="12">
            </div>
            <div class="control-group" style="margin-left: 15px;">
                <label>é€Ÿåº¦: <span id="speedVal">4</span></label>
                <input type="range" id="speedSlider" min="1" max="15" step="0.5" value="4">
            </div>
        </div>
        <div class="ui-row" style="justify-content: center; gap: 10px;">
            <button class="btn" id="decodeBtn" style="border-color:#f44; color:#f44; flex: 1.5;">âš¡ å•Ÿå‹•è§£å¯†</button>
            <button class="btn creator-only" id="shareBtn" style="border-color:#0af; color:#0af;">ğŸ”— åˆ†äº«</button>
        </div>
    </div>
</div>

<script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>

<script type="module">
    import * as THREE from 'three';

    class MatrixSecretApp {
        constructor() {
            this.scene = new THREE.Scene();
            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(this.renderer.domElement);

            this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            this.camera.position.z = 1000;
            
            this.raycaster = new THREE.Raycaster();
            this.mouse = new THREE.Vector2();
            
            this.params = { 
                speed: 4, originalSpeed: 4, midRows: 12, 
                decodeMsg: "", collectedIndices: new Set(),
                isCracking: false, lastDecodeTime: 0, 
                chars: "ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã„…ã„†ã„‡ã„ˆâ˜°â˜±ç”²ä¹™ä¸™ä¸å­ä¸‘åœ‹è‹±ç†åŒ–0123+âˆ’Ã—ABCéƒ­å•Ÿåˆ©"
            };
            this.charGroups = [];
            
            this._setupContext();
            this._initUI();
            this.updateRows();
            this._animate();
            window.addEventListener('resize', () => this.onResize());
        }

        _setupContext() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('text')) {
                this.params.decodeMsg = urlParams.get('text');
                this.params.midRows = parseInt(urlParams.get('rows')) || 12;
                this.params.speed = parseFloat(urlParams.get('speed')) || 4;
                this.params.originalSpeed = this.params.speed;
                document.getElementById('app-ui').classList.add('viewer-mode');
                document.querySelectorAll('.creator-only').forEach(el => el.classList.add('hidden'));
            }
        }

        _initUI() {
            const get = (id) => document.getElementById(id);
            const ui = get('app-ui');
            const overlay = get('touch-overlay');

            // é»æ“Šäº‹ä»¶ï¼šå€åˆ†ã€Œåˆ‡æ›é¢æ¿ã€èˆ‡ã€Œæ”¶é›†å­—å…ƒã€
            overlay.addEventListener('click', (e) => {
                if (this.params.isCracking) {
                    this._onPoint(e); // å˜—è©¦æ”¶é›†å­—å…ƒ
                } else {
                    if (!ui.classList.contains('viewer-mode')) ui.classList.toggle('show');
                }
            });

            get('rowSlider').oninput = (e) => { 
                this.params.midRows = parseInt(e.target.value); 
                get('rowVal').innerText = this.params.midRows;
                this.updateRows(); 
            };

            get('speedSlider').oninput = (e) => {
                if (!this.params.isCracking) {
                    this.params.speed = parseFloat(e.target.value);
                    this.params.originalSpeed = this.params.speed;
                    get('speedVal').innerText = this.params.speed;
                }
            };
            
            get('decodeBtn').onclick = (e) => {
                this.params.isCracking = !this.params.isCracking;
                e.target.classList.toggle('active', this.params.isCracking);
                e.target.innerText = this.params.isCracking ? "ğŸ›‘ åœæ­¢è§£å¯†" : "âš¡ å•Ÿå‹•è§£å¯†";
                
                get('crt-console').classList.toggle('active', this.params.isCracking);

                if (this.params.isCracking) {
                    this.params.originalSpeed = this.params.speed;
                    this.params.speed = 1;
                    if (!this.params.decodeMsg) this.params.decodeMsg = get('decodeInput').value;
                    this.params.collectedIndices.clear();
                    this._updateCRT();
                } else {
                    this.params.speed = this.params.originalSpeed;
                }
            };

            get('shareBtn').onclick = () => {
                const text = encodeURIComponent(get('decodeInput').value);
                const shareUrl = `${window.location.origin}${window.location.pathname}?text=${text}&rows=${get('rowSlider').value}&speed=${this.params.originalSpeed}`;
                navigator.clipboard.writeText(shareUrl).then(() => alert("é€£çµå·²è¤‡è£½ï¼"));
            };
        }

        _onPoint(event) {
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            this.raycaster.setFromCamera(this.mouse, this.camera);

            const intersects = this.raycaster.intersectObjects(this.scene.children, true);
            if (intersects.length > 0) {
                const obj = intersects[0].object.parent; // å–å¾— Group
                if (obj.userData.isD && !obj.userData.collected) {
                    obj.userData.collected = true;
                    this.params.collectedIndices.add(obj.userData.msgIdx);
                    obj.visible = false; // é»æ“Šå¾Œæ¶ˆå¤±
                    this._updateCRT();
                }
            }
        }

        _updateCRT() {
            let display = "";
            for (let i = 0; i < this.params.decodeMsg.length; i++) {
                display += this.params.collectedIndices.has(i) ? this.params.decodeMsg[i] : "_";
            }
            document.getElementById('crt-text').innerText = display;
        }

        _createTex(char, isNear, isRed) {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.font = '900 210px "Noto Sans TC"';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillStyle = isRed ? "#f44" : (isNear ? "#cfd" : "#0f4");
            ctx.shadowBlur = 20; ctx.shadowColor = isRed ? "#f00" : "#0f4";
            ctx.fillText(char, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        updateRows() {
            this.charGroups.forEach(g => { 
                g.children.forEach(c => { c.material.map.dispose(); c.material.dispose(); });
                this.scene.remove(g); 
            });
            this.charGroups = [];
            const layers = [
                { n: 'F', z: -950, sz: 60, m: 2.8, sp: 2.2 },
                { n: 'M', z: 0,    sz: 90, m: 1.0, sp: 1.3 }, 
                { n: 'N', z: 450,  sz: 130,m: 0.6, sp: 1.0 }
            ];
            layers.forEach(l => {
                const rows = Math.max(1, Math.floor(this.params.midRows * l.m));
                const spacing = (window.innerWidth * (1 + Math.abs(l.z)/1000) * l.sp) / rows;
                for (let r = 0; r < rows; r++) {
                    const g = new THREE.Group();
                    const rc = this.params.chars[Math.floor(Math.random()*this.params.chars.length)];
                    const rt = this._createTex(rc, l.n==='N', false);
                    for (let i = 0; i < 5; i++) {
                        const m = new THREE.Mesh(new THREE.PlaneGeometry(l.sz, l.sz), new THREE.MeshBasicMaterial({ map: rt, transparent: true, side: THREE.DoubleSide, color: new THREE.Color(1,1,1).multiplyScalar(1-i*0.15)}));
                        m.position.z = -i * 4.0; g.add(m);
                    }
                    g.userData = { l, off: Math.random()*1000, spd: 0.8+Math.random()*0.4, rotSpd: (Math.random()-0.5)*0.08, isD: false, collected: false };
                    g.position.set((r - (rows - 1)/2) * spacing, 2000, l.z);
                    this.scene.add(g);
                    this.charGroups.push(g);
                }
            });
        }

        _animate() {
            const now = Date.now();
            const time = now * 0.001 * this.params.speed;

            if (this.params.isCracking && this.params.decodeMsg.length > 0) {
                if (now - this.params.lastDecodeTime > 300) {
                    // æ‰¾å‡ºå°šæœªè¢«æ”¶é›†çš„å­—å…ƒç´¢å¼•
                    const remainingIndices = [];
                    for(let i=0; i<this.params.decodeMsg.length; i++) {
                        if(!this.params.collectedIndices.has(i)) remainingIndices.push(i);
                    }
                    
                    if (remainingIndices.length > 0) {
                        const pool = this.charGroups.filter(g => !g.userData.isD && g.userData.l.n !== 'F' && Math.abs(g.position.y) < 800);
                        if (pool.length > 0) {
                            const t = pool[Math.floor(Math.random()*pool.length)];
                            const targetIdx = remainingIndices[Math.floor(Math.random()*remainingIndices.length)];
                            const newTex = this._createTex(this.params.decodeMsg[targetIdx], t.userData.l.n==='N', true);
                            t.children.forEach(c => { c.material.map = newTex; });
                            t.userData.isD = true;
                            t.userData.msgIdx = targetIdx; // ç¶å®šå®ƒæ˜¯è¨Šæ¯çš„ç¬¬å¹¾å€‹å­—
                            this.params.lastDecodeTime = now;
                        }
                    }
                }
            }

            this.charGroups.forEach(g => {
                const p = (time * g.userData.l.m * g.userData.spd + g.userData.off) % 6;
                g.position.y = 1500 - p * 600;
                g.rotation.y += g.userData.rotSpd;

                // åªæœ‰æ²’è¢«é»æ“Šæ”¶é›†çš„æ‰é¡¯ç¤º
                if (g.position.y < -1100) {
                    g.userData.isD = false;
                    g.userData.collected = false;
                    g.visible = true; 
                    const rc = this.params.chars[Math.floor(Math.random()*this.params.chars.length)];
                    const resetTex = this._createTex(rc, g.userData.l.n==='N', false);
                    g.children.forEach(c => { c.material.map = resetTex; });
                }
            });
            this.renderer.render(this.scene, this.camera);
            requestAnimationFrame(() => this._animate());
        }

        onResize() {
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.updateRows();
        }
    }
    new MatrixSecretApp();
</script>
</body>
</html>
